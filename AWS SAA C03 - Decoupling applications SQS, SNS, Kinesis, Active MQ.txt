Deploying multiple applications/Services will require to communicate with each other. Services communicating directly with each other is all synchronous communication with no middleware. Services communicatitng to a queue is called asynchronous communication with a queue as middleware. Issue with sync comms is that if one services has a traffic spike, the whole app would crash. Async comms will decouple services so that if one fails, the rest work as is since they are talking to a queue rather than the service. For decoupling you can use SQS: Queue model; SNS: pub/sub model; Kinesis: real-time streaming model.

A queue basically takes messages from services called producers (like process a video or order), then services called consumers will pull the messages from the queue from the other end, once the message is processed, it gets deleted from the queue.

Amazon SQS - standard queue is the oldest offering (10 years old) and is a fully managed service used to decouple applications. SQS provides unlimited throughput, unlimited number of messages in queue, default retention of messages is 4 days and max 14 days, low latency of about <10ms on pub and receive. Limitation of 256KB per message sent. Can have duplicate messages (at least once delivery, occasionally), can have out of order messages (best effort ordering). Also provides FIFO type of queue as well.

Message is produced to SQS using the SDK (SendMessage API). The message is persisted in SQS until a consumer deletes it. Example send an order to be processed with custom attributes like order id, customer id etc. Message is consumed by consumers (e.g EC2, servers, Lambda), Consumer polls SQS for messages (receive upto 10 messages at a time) then process the messages (e.g insert an order into RDS) and finally delete the messages using the DeleteMessage API after processing. Multiple consumers receive and process messages in parallel. At least once delivery and best-effort message ordering is applied here. We can scale consumers horizontally to improve throughput of processing.

Using SQS with ASG is a great strategy with CloudWatch Metric attached to the SQS queue. CloudWatch will check for queue length (using ApproximateNumberOfMessages metric query) and will sound a CloudWatch alarm if the queue length breaches the limit, causing the ASG to increase the number of instances to manage the traffic spike or workload.

Another great usecase is to decouple a Front web-app for video processing into two ASG groups rather than using a single instance with ASG. The front-end layer of the app would take the requests (present in its own ASG and sized accordingly) and forward them to SQS which would then be received by the backend layer of the app for video processing in its own ASG (this one can have a GPU optionally) and then the processed video is stored in S3.

For security, SQS has encryption, using HTTPS API for in-flight and KMS keys at-rest (SSE-SQS or SSE-KMS). Client-side encryption if the client wants to perform encryption/decryption themselves (not supported out of the box). Access control's managed using IAM policies to regulate access to the SQS API. SQS Access Policies (similar to S3 bucket policies) are useful for cross-account access to SQS queues and are useful for alowing other services (SNS, S3..) to write to an SQS queue.
