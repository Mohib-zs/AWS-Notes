A stateful app likes myclothes.com which allows people to buy clothes online. It has a shopping cart, and the website has hundreds of user at the same time. We need to scale, maintain horizontal  scalability and keep the web app as stateless as possible, users should not loes their shopping cart and user should have their details (address, etc) in a database.

When user goes to one instance of the three via ALB and puts something in the shopping cart, the very next thing redirect causes them to lose the contents of shopping cart.

Solution for this could be stickiness, using session affinity we can make the request and the redirected requests go to the same instance but flaw is that if the instance in the asg gets deleted, user still loses the shopping cart. (connection draining could be a solution for this however)

Another solution for this is user cookies where user stores the content of the shopping cart rather than the instances and sends web cookies with each of their http request which can go to any instance, telling them that he already has items in the shopping cart via the cookies. This makes the web app stateless as content is now stored with user, but the flaws are that http requests are heavier and cookies can be altered by attackers causing a security risk so always ensure ec2 instances validate the cookies. Cookies must be less than 4KB so can't store big datasets.

Another solution can be to introduce server session, where when data is added to cart in instance, instance stores cart data in elasticache cluster, so when request is redirected to another instance, it fetches the cart data from the cache and retrieve the session data in sub-millisecond speed. Alternative is DynamoDB, and for storing user data we can use Amazon RDS which is great for long-term storage and for relational data storage. We can also use RDS cluster where master is used for writes while upto 15 read replicas can be used to scale reads. We can use another alternative called Lazy loading where we instance when asked to retrive info, first goes to elasticache, if info is found then it is cache hit otherwise it goes to RDS to retrieve data and then store it in cache. This helps in faster data retrieval and less load on RDS. One flaw is that elasticache requires cache maintainence which is a bit difficult and has to be done from application side.

A stateful web app like MyWordPress.com where we try to create a fully scalable WordPress website, it should access and correctly display picture uploads, our user data, and the blog content should be stored in a MySQL database. We can use Aurora for RDS due to its performance and features and the less operational overhead it requires.

You may use Ec2 with EBS to store images, works when you have 1 instance but multiple will ec2 instance will cause issues because 1 ebs will have the image and the other one wont. Solution is to use EFS which is shared storage and is connected to multiple instances in different azs via ENIs EFS creates specifically for itself. Meaning EBS is great for single instance apps while EFS is great for distributed applications.

To instantiate (quick start) applications quickly for EC2 instances you can use a Golden AMI, where you install the application and dependencies in one instance and then start the rest of the instances using the first instances AMI, or if dynamic configs are required for each instance then you may use user data scripts. Go hybrid with Golden AMI and User Data if possible for best approach (Elastic Beanstalk).

For RDS databases, restore from a snapshot and the database will have schemas and data ready.

For EBS volumes, restore from a snapshot and the disk will already be formatted and have data. Elasticache is used to store and retrieve session data + cache data.

Elastic Beanstalk is a developer centric view of deploying an application on AWS, it uses all the components we've seen before; EC2, ASG, ELB, RDS,... Its also a managed service which automatically handles capacity provisioning, load balancing, scaling, application health monitoring, instance configuration etc. We still have full control over the configuration. Beanstalk is free but you pay for the underlying instances.

Elastic beanstalk components include collection of Beanstalk components (environments, version, configurations,...) Application version: an iteration of your application code. An environment is a collection of AWS resources running an application version (only one application version at a time) Tiers are Web Server Environment Tier & Worker Environment Tier. You can create multiple environments (dev, test, prod...). You can update the version by uploading a new version and then deploy that version into our environment to update the version. There are two environments in Elastic Beanstalk, one is Web Environment used to server HTTP Traffic with ALB/ELB, ASG, Route 53, CloudWatch with Nginx or Apache as a reverse proxy. The other is worker envrionment used for background jobs or asynchronous tasks using Amazon SQS like sending emails, processing images and generating reports. No ALB/NLB required as its not intended for HTTP traffic though your app must include a /worker HTTP endpoint to receive jobs from the queue. You control polling and job processing logic.

They can work together as well like a e-commerce site which uses web environment for the website and API along with a Worker environment that sends email receipts, processes orders and generates invoices. Beanstalk also has two deployment modes, one is the single instance which is great for dev with one EC2 instance and elastic ip and a RDS master. Second is high availability with load balancer and asg enabled for multi-az EC2 and RDS with one being master and the other standby.