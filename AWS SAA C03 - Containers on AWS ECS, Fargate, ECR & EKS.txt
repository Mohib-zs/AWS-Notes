ECS (Elastic Container Service) is used to launch Docker containers on AWS (aka Launch ECS tasks on ECS Clusters).

For launch type, if you use EC2 launch, then you must provision and maintain the infra (ec2 instances) yourself. Each Ec2 instance must run the ECS agent to register in the ECS cluster. AWS takes care of starting/stopping containers.

For launch type, if you use Fargate launch, then you do not provision the infra (no EC2 instances to manage), Its all serverless. You just create task definitions, AWS then just runs the ECS tasks for you based on the required CPU/RAM. To scale, just increase the number of tasks, you can see the containers but not an instance where the container may be located in. There is also Fargate spot launch option which allows you to launch serverless spot instances in ECS cluster.

IAM Role for ECS is EC2 Instance profile role (EC2 launch type only): Its used by the ECS agent, makes API calls to ECS service, send container logs to CloudWatch Logs, Pull Docker image from ECR, Reference sensitive data in secrets manager or SSM Parameter store. ECS task role allows each task to have a specific role (e.g make api calls to S3 or Dynamo DB), use different role for the different ECS services you run, task role is defined in the task definition.

Amazon ECS (both EC2 and Fargate launch types) can integrated with ELB. Like Most ECS tasks can be fronted over an ALB with HTTP(S) endpoints for the users to access them via the ALB (works for most cases). Can use NLB but usually for high throughput/performance use cases or pair it with AWS Private Link.

ECS - Data Volumes: You can mount EFS file systems onto ECS tasks, works both for EC2 and Fargate launch types. Tasks running in any az will share the same data in the EFS file system. Ultimate Serverless combo is to use Fargate + EFS = Fully serverless. Usecases are persistent multi-az shared storage for your containers. Amazon S3 cannot be mounted as a file system.

ECS service auto scaling automatically increases/decreases the desired number of ECS tasks, Amazon ECS Auto Scaling uses AWS Application Auto Scaling, scaling metrics are ECS service average CPU utilization, average memory utilization or ALB Request count per target. You can use Target tracking to scale based on target value for a specific cloudwatch metric, step scaling to scale based on a specified cloudwatch alarm, scheduled scaling to scale based on a specified date/time (predictable changes). ECS Service Auto Scaling (task level) is not equal to EC2 Auto scaling (EC2 instance level). Fargate Auto Scaling is much easier to setup (because serverless)

ECS service scaling is done by adding underlying EC2 instances, two ways of doing it. Using Auto Scaling Group scaling or by ECS Cluster Capacity Provider (much better option). It works by automatically scaling the infra for your ECS tasks, its paired with an ASG and adds EC2 instances when you're missing capacity like CPU/RAM to add new tasks.


Possible solution architecture for ECS with Fargate (for fully serverless solution) is ECS tasks invoked by Event Bridge, where suppose the users upload something to S3 bucket which is connected to Amazon Eventbridge, on every S3 event, Eventbridge has a rule to invoke an ECS task, the ECS task will have a task role to access S3/DynamoDB, it will process the image/video in the bucket and save it in DynamoDB. Similar serverless solution is to create a rule in Eventbridge which would trigger every hour to create a task in ECS fargate to perform batch processing on objects present in S3.

Another solution is for an SQS queue which is connected to the ECS cluster service, where each task in the service polls the queue for messages. The service also has service auto scaling enabled which increases the number of tasks based on the number of messages in the queue.

Another solution in ECS is to intercept stopped tasks using eventbridge, where if a container in a task fails or is stopped, the eventbridge will show it as an event, the event will trigger a notification (e.g email) using SNS to the administrator.

ECR is a private registry per account and is also a public registry known as ECR gallery. Fully intergrated with ECS, and BTS, ECR is backed by S3 (meaning images are actually stored in S3). ECR access is controlled by IAM, meaning instances in ECS will need an IAM role to access ECR to pull images and create containers. Provides Image vulnerability scanning, tags, versioning and image lifecycle.

EKS is managed Kubernetes service on AWS, Similar to ECS but different API, supports EC2 instances as worker nodes or fargate to deploy serverless containers. Usecases is if a company running Kubernetes on-prem wants to move to AWS, then can choose EKS. Kubernetes is cloud agnostic (can be used in Azure, GCP etc.). Node types are Managed Node Groups, where AWS creates and manages nodes (ec2 instances) for you, nodes are part of ASG managed by EKS, nodes can be On-Demand or Spot instances. Second type is self-managed nodes created by you and registered on EKS cluster and managed by an ASG, you may use a pre-buily AMI of EKS for optimized performance and it supports both on-demand and spot instances. Third is AWS fargate which has no nodes to manage, just run the containers. EKS Data-volume require you to specify StorageClass (Exam Keyword) manifest in the cluster and it leverages a Container Storage Interface (CSI) (Exam keyword) compliant driver. Support for EBS, EFS (works only with fargate), FSx for Lustre and FSx for NetApp ONTAP.

AWS App Runner is a fully managed service that makes it easy to deploy web applications and APIs at scale. No infrastructure experience required by you, deploy application via its source code or container image, automatically builds and deploys the web app, provides auto scaling, HA, load balancer, encryption. Provides access to your VPC so it can connect to a database or cache, message queue service etc. Use cases are web apps, APIs, microservices, rapid production deployments.

AWS App2Container (A2C) is a CLI tool for migrating and modernizing Java and .NET web apps into Docker Containers. It uses Lift-and-shift method to migrate your apps running in on-prem bare metal, vms, or any cloud to AWS. Accelerates modernization by migrating legacy apps without code changes. Generates CloudFormation templates (compute, network..) Registers generated Docker images to ECR, can be deployed to ECS, EKS and App Runner. Works by discovering and analyzing the apps that can be migrated, extracts the app and containerizes it, generates artifacts like ECS tasks, EKS pod defs, CloudFormation templates or CI/CD pipelines. Stores in ECR and deploys in AWS.